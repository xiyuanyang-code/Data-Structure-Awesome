// !originated from Class_implementation/PriorityQueue.cpp
// !modified and generated by gemini-flash 2.5, tests all passed

#include <algorithm>// For std::swap, std::copy
#include <chrono>   // For std::chrono
#include <iostream>
#include <random>   // For std::random_device, std::mt19937, std::uniform_int_distribution
#include <stdexcept>// For std::underflow_error

// --- Priority Queue Class Definition ---

/**
 * @brief A custom implementation of a Min-Priority Queue using a binary heap.
 * Elements are stored in a 1-based array, meaning array[0] is unused.
 * The smallest element is always at the root (array[1]).
 * @tparam T The type of elements stored in the priority queue.
 * Must support comparison operators (<).
 */
template<class T>
class PriorityQueue {
public:
    size_t current_size;// Current number of elements in the heap
    T *array;           // Dynamically allocated array to store heap elements
    size_t max_size;    // Maximum capacity of the array

    /**
     * @brief Doubles the capacity of the underlying array when it's full.
     */
    void doublespace() {
        // Define a growth factor, e.g., 2.
        // It's common to grow by 1.5 or 2 times.
        size_t new_max_size = max_size * 2;
        if (new_max_size == 0) {// Handle initial 0 capacity case if needed, though unlikely with default 100
            new_max_size = 1;
        }

        T *old_array = array;
        array = new T[new_max_size];// Allocate new, larger array

        // Copy elements from old array to new array (including array[0] which is unused)
        // Using std::copy for safety and efficiency
        std::copy(old_array, old_array + current_size + 1, array);

        delete[] old_array;// Free the old array
        max_size = new_max_size;
    }

    /**
     * @brief Builds a min-heap from an array of elements.
     * Starts from the last non-leaf node and percolates down.
     */
    void buildheap() {
        // Start from the last non-leaf node (parent of the last element)
        // and go up to the root (index 1).
        for (size_t i = current_size / 2; i >= 1; --i) {
            percolateDown(i);
        }
    }

    /**
     * @brief Percolates an element down from `hole` to maintain heap property.
     * This is used after extracting the minimum element or during heap construction.
     * @param hole The index from which to start percolating down.
     */
    void percolateDown(size_t hole) {
        size_t child_idx;
        T temp_value = array[hole];// Element to be percolated down

        while (hole * 2 <= current_size) {// While 'hole' has at least a left child
            child_idx = hole * 2;         // Assume left child is the smaller one

            // If a right child exists and is smaller than the left child, choose the right child
            if (child_idx + 1 <= current_size && array[child_idx + 1] < array[child_idx]) {
                ++child_idx;// Move to the right child
            }

            // If the smaller child is less than `temp_value`, move child up and move hole down
            if (array[child_idx] < temp_value) {
                array[hole] = array[child_idx];
                hole = child_idx;
            } else {
                // `temp_value` is in its correct position relative to its children
                break;
            }
        }
        array[hole] = temp_value;// Place `temp_value` into its final position
    }

    /**
     * @brief Percolates an element up from `hole` to maintain heap property.
     * This is used after inserting a new element.
     * @param hole The index from which to start percolating up.
     * @param value The value to be percolated up.
     */
    void percolateUp(size_t hole, const T &value) {
        // While not at the root (index 1) and value is smaller than parent
        while (hole > 1 && value < array[hole / 2]) {
            array[hole] = array[hole / 2];// Move parent down
            hole /= 2;                    // Move hole up
        }
        array[hole] = value;// Place value into its final position
    }

public:
    /**
     * @brief Default constructor for PriorityQueue.
     * @param capacity Initial capacity of the underlying array.
     */
    explicit PriorityQueue(size_t capacity = 100)
        : current_size(0), max_size(capacity + 1) {// +1 because array[0] is unused
        if (capacity == 0) max_size = 1;           // Ensure at least 1 for array[0] even if capacity is 0
        array = new T[max_size];
    }

    /**
     * @brief Destructor for PriorityQueue. Frees dynamically allocated memory.
     */
    ~PriorityQueue() {
        delete[] array;
    }

    /**
     * @brief Constructor for PriorityQueue, builds a heap from an existing array.
     * @param data Pointer to the array of elements.
     * @param size The number of elements in the `data` array.
     */
    PriorityQueue(const T *data, size_t size)
        : current_size(size), max_size(size + 1 + 10) {// +1 for 1-based indexing, +10 for buffer
        array = new T[max_size];
        // Copy elements from data (0-based) to array (1-based)
        for (size_t i = 0; i < size; ++i) {
            array[i + 1] = data[i];
        }
        buildheap();// Build the heap after copying elements
    }

    // --- Rule of Five (for resource management) ---
    // 1. Copy Constructor
    PriorityQueue(const PriorityQueue &other)
        : current_size(other.current_size), max_size(other.max_size) {
        array = new T[max_size];
        std::copy(other.array, other.array + other.current_size + 1, array);
    }

    // 2. Copy Assignment Operator
    PriorityQueue &operator=(const PriorityQueue &other) {
        if (this != &other) {// Handle self-assignment
            // Free existing resources
            delete[] array;

            // Allocate new resources and copy
            current_size = other.current_size;
            max_size = other.max_size;
            array = new T[max_size];
            std::copy(other.array, other.array + other.current_size + 1, array);
        }
        return *this;
    }

    // 3. Move Constructor (C++11 and later)
    PriorityQueue(PriorityQueue &&other) noexcept
        : current_size(other.current_size),
          max_size(other.max_size),
          array(other.array) {
        // Leave the source object in a valid, but unspecified state (e.g., empty)
        other.current_size = 0;
        other.max_size = 0;
        other.array = nullptr;
    }

    // 4. Move Assignment Operator (C++11 and later)
    PriorityQueue &operator=(PriorityQueue &&other) noexcept {
        if (this != &other) {// Handle self-assignment
            delete[] array;  // Free existing resources

            current_size = other.current_size;
            max_size = other.max_size;
            array = other.array;

            // Leave the source object in a valid, but unspecified state (e.g., empty)
            other.current_size = 0;
            other.max_size = 0;
            other.array = nullptr;
        }
        return *this;
    }
    // --- End of Rule of Five ---

    /**
     * @brief Checks if the priority queue is empty.
     * @return True if the queue contains no elements, false otherwise.
     */
    bool empty() const {
        return current_size == 0;
    }

    /**
     * @brief Inserts a new element into the priority queue.
     * @param x The element to be inserted.
     */
    void enQueue(const T &x) {
        if (current_size == max_size - 1) {// Check if array is full (max_size-1 because array[0] is unused)
            doublespace();
        }

        current_size++;
        percolateUp(current_size, x);// Percolate the new element up from the last position
    }

    /**
     * @brief Removes and returns the smallest element from the priority queue.
     * @return The smallest element.
     * @throws std::underflow_error if the priority queue is empty.
     */
    T deQueue() {
        if (empty()) {
            throw std::underflow_error("Priority queue is empty");
        }

        T min_item = array[1];           // The smallest item is at the root
        array[1] = array[current_size--];// Move the last element to the root
        percolateDown(1);                // Percolate down the new root to maintain heap property
        return min_item;
    }

    /**
     * @brief Returns the smallest element in the priority queue without removing it.
     * @return The smallest element.
     * @throws std::underflow_error if the priority queue is empty.
     */
    T getHead() const {
        if (empty()) {
            throw std::underflow_error("Priority queue is empty");
        }
        return array[1];// The smallest item is at the root
    }

    /**
     * @brief Prints the current state of the heap array (for debugging).
     */
    void print_heap_array() const {
        std::cout << "Heap Array (1-based, size=" << current_size << ", capacity=" << max_size << "): [";
        for (size_t i = 1; i <= current_size; ++i) {
            std::cout << array[i] << (i == current_size ? "" : ", ");
        }
        std::cout << "]" << std::endl;
    }
};

// --- Heap Sort Function (using the custom PriorityQueue) ---

/**
 * @brief Sorts an array using the custom PriorityQueue.
 * Note: This is a copy-based sort, meaning it consumes the input array
 * by putting it into a PQ and then extracting it into a new sorted array.
 * The original `arr` pointer is updated to point to the new sorted array.
 * Time Complexity: O(N log N)
 * Space Complexity: O(N) due to the priority queue and the new sorted array.
 * @tparam T The type of elements to be sorted.
 * @param arr A reference to the pointer of the array to be sorted.
 * @param size The number of elements in the array.
 */
template<typename T>
void heapSort(T *&arr, size_t size) {
    if (size == 0) return;

    // Build a priority queue from the input array
    PriorityQueue<T> pq(arr, size);

    // Allocate a new array for the sorted elements
    T *sorted_arr = new T[size];

    // Dequeue elements one by one into the new array
    for (size_t i = 0; i < size; ++i) {
        sorted_arr[i] = pq.deQueue();
    }

    // Free the old unsorted array and update the pointer
    delete[] arr;
    arr = sorted_arr;
}

// --- Test Utilities ---

/**
 * @brief Generates a random integer.
 * @return A random integer.
 */
int generate_random_int() {
    static std::random_device rd;
    static std::mt19937 gen(rd());
    static std::uniform_int_distribution<> dis(1, 100000);// Values between 1 and 100,000
    return dis(gen);
}

/**
 * @brief Checks if an array is sorted in ascending order.
 * @tparam T The type of elements in the array.
 * @param arr Pointer to the array.
 * @param size The number of elements in the array.
 * @return True if sorted, false otherwise.
 */
template<typename T>
bool is_sorted(const T *arr, size_t size) {
    for (size_t i = 1; i < size; ++i) {
        if (arr[i] < arr[i - 1]) {
            return false;
        }
    }
    return true;
}

/**
 * @brief Prints the elements of an array.
 * @tparam T The type of elements in the array.
 * @param arr Pointer to the array.
 * @param size The number of elements in the array.
 * @param limit Optional: maximum number of elements to print.
 */
template<typename T>
void print_array(const T *arr, size_t size, size_t limit = 20) {
    std::cout << "[";
    for (size_t i = 0; i < std::min(size, limit); ++i) {
        std::cout << arr[i] << (i == std::min(size, limit) - 1 ? "" : ", ");
    }
    if (size > limit) {
        std::cout << " ...";
    }
    std::cout << "]" << std::endl;
}

// --- Main Test Function ---

int main() {
    std::cout << "--- Custom Priority Queue and Heap Sort Tests ---" << std::endl;

    // Test Case 1: Basic functionality (enQueue, deQueue, getHead)
    std::cout << "\n--- Test Case 1: Basic Priority Queue Operations ---" << std::endl;
    PriorityQueue<int> pq_test;
    pq_test.enQueue(10);
    pq_test.enQueue(5);
    pq_test.enQueue(20);
    pq_test.enQueue(2);
    pq_test.enQueue(15);

    std::cout << "Queue after insertions: ";
    pq_test.print_heap_array();
    std::cout << "Head (min): " << pq_test.getHead() << std::endl;// Expected: 2

    std::cout << "Dequeuing elements: ";
    while (!pq_test.empty()) {
        std::cout << pq_test.deQueue() << " ";
    }
    std::cout << std::endl;// Expected: 2 5 10 15 20

    // Test Case 2: Constructor from array and buildheap
    std::cout << "\n--- Test Case 2: Priority Queue from Array (Build Heap) ---" << std::endl;
    int data[] = {30, 10, 50, 20, 40, 5, 25};
    size_t data_size = sizeof(data) / sizeof(data[0]);
    std::cout << "Initial array: ";
    print_array(data, data_size);

    PriorityQueue<int> pq_from_array(data, data_size);
    std::cout << "PQ after building from array: ";
    pq_from_array.print_heap_array();
    std::cout << "Head (min): " << pq_from_array.getHead() << std::endl;// Expected: 5

    std::cout << "Dequeuing elements: ";
    while (!pq_from_array.empty()) {
        std::cout << pq_from_array.deQueue() << " ";
    }
    std::cout << std::endl;// Expected: 5 10 20 25 30 40 50

    // Test Case 3: Empty queue and underflow_error
    std::cout << "\n--- Test Case 3: Empty Queue and Error Handling ---" << std::endl;
    PriorityQueue<double> empty_pq;
    std::cout << "Is empty_pq empty? " << (empty_pq.empty() ? "Yes" : "No") << std::endl;
    try {
        empty_pq.deQueue();
    } catch (const std::underflow_error &e) {
        std::cout << "Caught expected exception: " << e.what() << std::endl;
    }
    try {
        empty_pq.getHead();
    } catch (const std::underflow_error &e) {
        std::cout << "Caught expected exception: " << e.what() << std::endl;
    }

    // Test Case 4: `doublespace` functionality
    std::cout << "\n--- Test Case 4: `doublespace` (Capacity Expansion) ---" << std::endl;
    PriorityQueue<int> small_pq(3);// Start with a small capacity
    std::cout << "Initial capacity: " << small_pq.max_size << std::endl;
    small_pq.enQueue(1);// current_size = 1
    small_pq.enQueue(2);// current_size = 2
    small_pq.enQueue(3);// current_size = 3. Now full if max_size was 4 (capacity 3 + unused 0-index)
    std::cout << "After 3 enQueues, current size: " << small_pq.current_size << ", capacity: " << small_pq.max_size << std::endl;
    small_pq.enQueue(4);// Should trigger doublespace
    std::cout << "After 4th enQueue, current size: " << small_pq.current_size << ", new capacity: " << small_pq.max_size << std::endl;
    small_pq.print_heap_array();


    // Test Case 5: Heap Sort with random data
    std::cout << "\n--- Test Case 5: Heap Sort with Random Data ---" << std::endl;
    const size_t test_sizes[] = {0, 1, 10, 100, 1000, 10000, 100000};

    for (size_t current_test_size : test_sizes) {
        std::cout << "\nSorting " << current_test_size << " elements..." << std::endl;

        int *arr_to_sort = new int[current_test_size];
        for (size_t i = 0; i < current_test_size; ++i) {
            arr_to_sort[i] = generate_random_int();
        }

        std::cout << "Original array (first few): ";
        print_array(arr_to_sort, current_test_size);

        auto start_time = std::chrono::high_resolution_clock::now();
        heapSort(arr_to_sort, current_test_size);// arr_to_sort will be updated to point to the sorted array
        auto end_time = std::chrono::high_resolution_clock::now();
        std::chrono::duration<double> elapsed_time = end_time - start_time;

        std::cout << "Sorted array (first few): ";
        print_array(arr_to_sort, current_test_size);

        if (is_sorted(arr_to_sort, current_test_size)) {
            std::cout << "Status: PASS - Array is sorted." << std::endl;
        } else {
            std::cout << "Status: FAIL - Array is NOT sorted!" << std::endl;
        }
        std::cout << "Time taken: " << elapsed_time.count() * 1000 << " ms" << std::endl;

        delete[] arr_to_sort;// Free the sorted array
    }

    // Test Case 6: Edge Cases for Heap Sort
    std::cout << "\n--- Test Case 6: Heap Sort Edge Cases ---" << std::endl;

    // Already sorted array
    std::cout << "\nTest: Already Sorted Array (100 elements)" << std::endl;
    int *sorted_arr = new int[100];
    for (int i = 0; i < 100; ++i) sorted_arr[i] = i;
    heapSort(sorted_arr, 100);
    std::cout << "Is sorted: " << (is_sorted(sorted_arr, 100) ? "PASS" : "FAIL") << std::endl;
    delete[] sorted_arr;

    // Reverse sorted array
    std::cout << "\nTest: Reverse Sorted Array (100 elements)" << std::endl;
    int *reverse_arr = new int[100];
    for (int i = 0; i < 100; ++i) reverse_arr[i] = 99 - i;
    heapSort(reverse_arr, 100);
    std::cout << "Is sorted: " << (is_sorted(reverse_arr, 100) ? "PASS" : "FAIL") << std::endl;
    delete[] reverse_arr;

    // Array with all duplicate elements
    std::cout << "\nTest: Array with Duplicates (100 elements, all 5)" << std::endl;
    int *duplicate_arr = new int[100];
    for (int i = 0; i < 100; ++i) duplicate_arr[i] = 5;
    heapSort(duplicate_arr, 100);
    std::cout << "Is sorted: " << (is_sorted(duplicate_arr, 100) ? "PASS" : "FAIL") << std::endl;
    delete[] duplicate_arr;

    // Test Case 7: Copy and Move Semantics (Rule of Five)
    std::cout << "\n--- Test Case 7: Copy and Move Semantics ---" << std::endl;
    PriorityQueue<int> original_pq;
    original_pq.enQueue(5);
    original_pq.enQueue(1);
    original_pq.enQueue(10);
    std::cout << "Original PQ: ";
    original_pq.print_heap_array();

    // Copy constructor
    PriorityQueue<int> copied_pq = original_pq;
    std::cout << "Copied PQ:   ";
    copied_pq.print_heap_array();
    // Modify original to show they are independent
    original_pq.enQueue(0);
    std::cout << "Original PQ after mod: ";
    original_pq.print_heap_array();
    std::cout << "Copied PQ (unchanged): ";
    copied_pq.print_heap_array();

    // Copy assignment
    PriorityQueue<int> another_pq(20);
    another_pq.enQueue(100);
    std::cout << "Another PQ before assign: ";
    another_pq.print_heap_array();
    another_pq = copied_pq;// Copy assign
    std::cout << "Another PQ after assign from Copied: ";
    another_pq.print_heap_array();
    std::cout << "Copied PQ (unchanged): ";
    copied_pq.print_heap_array();// Should remain unchanged

    // Move constructor
    PriorityQueue<int> moved_pq = std::move(original_pq);
    std::cout << "Moved PQ (from original): ";
    moved_pq.print_heap_array();
    std::cout << "Original PQ (after move - should be empty/null): ";
    original_pq.print_heap_array();// Should be empty/invalid state

    // Move assignment
    PriorityQueue<int> final_pq;
    final_pq.enQueue(999);
    std::cout << "Final PQ before move assign: ";
    final_pq.print_heap_array();
    final_pq = std::move(moved_pq);
    std::cout << "Final PQ after move assign from Moved: ";
    final_pq.print_heap_array();
    std::cout << "Moved PQ (after move - should be empty/null): ";
    moved_pq.print_heap_array();// Should be empty/invalid state

    return 0;
}