// !forked from Sorting.cpp
// !generated by gemini flash 2.5, all tests passed

#include <algorithm>// For std::swap
#include <chrono>   // For std::chrono
#include <iostream>
#include <queue> // For std::priority_queue in heapSort
#include <random>// For std::random_device, std::mt19937, std::uniform_int_distribution
#include <string>
#include <vector>

// --- Data Structures ---
template<class KEY, class OTHER>
struct Set {
    KEY key = KEY();
    OTHER other = OTHER();

    // Overload stream insertion operator for easy printing
    friend std::ostream &operator<<(std::ostream &os, const Set<KEY, OTHER> &s) {
        os << "{" << s.key << ", " << s.other << "}";
        return os;
    }
};

// Define SortFunction as a function pointer type
template<class Key, class Other>
using SortFunction = void (*)(Set<Key, Other> *, int);

// --- Helper Functions ---

/**
 * @brief Generates a random integer between 1 and 100,000.
 * @return A random integer.
 */
int generate_random_int() {
    static std::random_device rd;
    static std::mt19937 gen(rd());
    static std::uniform_int_distribution<> dis(1, 100000);
    return dis(gen);
}

/**
 * @brief Generates a random string of a given length.
 * @param length The desired length of the string.
 * @return A random string.
 */
std::string generate_random_string(int length) {
    const char charset[] =
            "abcdefghijklmnopqrstuvwxyz"
            "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
            "0123456789";// Added numbers for more variety
    const int charset_size = sizeof(charset) - 1;

    std::string result;
    result.reserve(length);

    // Use a more robust random number generator
    static std::random_device rd;
    static std::mt19937 gen(rd());
    static std::uniform_int_distribution<> dis(0, charset_size - 1);

    for (int i = 0; i < length; i++) {
        result += charset[dis(gen)];
    }
    return result;
}

// --- Sorting Algorithms ---

/**
 * @brief Sorts an array using the Simple Insertion Sort algorithm.
 * Time Complexity: O(N^2) in worst and average cases, O(N) in best case.
 * Space Complexity: O(1).
 * @tparam Key Type of the key.
 * @tparam Other Type of the other data.
 * @param a Pointer to the array of Set objects.
 * @param size The number of elements in the array.
 */
template<class Key, class Other>
void simpleInsertSort(Set<Key, Other> *a, int size) {
    for (int i = 1; i < size; ++i) {
        Set<Key, Other> tmp = a[i];
        int k = i - 1;
        // Shift elements greater than tmp.key to the right
        while (k >= 0 && tmp.key < a[k].key) {
            a[k + 1] = a[k];
            --k;
        }
        a[k + 1] = tmp;// Insert tmp into its correct position
    }
}

/**
 * @brief Sorts an array using the Shell Sort algorithm.
 * Time Complexity: Depends on gap sequence, typically O(N log^2 N) or O(N^(3/2)).
 * Space Complexity: O(1).
 * @tparam Key Type of the key.
 * @tparam Other Type of the other data.
 * @param a Pointer to the array of Set objects.
 * @param size The number of elements in the array.
 */
template<class Key, class Other>
void shellSort(Set<Key, Other> *a, int size) {
    for (int step = size / 2; step > 0; step /= 2) {
        // Perform insertion sort with a step size
        for (int i = step; i < size; ++i) {
            Set<Key, Other> tmp = a[i];
            int j = i - step;
            while (j >= 0 && a[j].key > tmp.key) {
                a[j + step] = a[j];
                j -= step;
            }
            a[j + step] = tmp;
        }
    }
}

/**
 * @brief Sorts an array using Heap Sort with `std::priority_queue` (min-heap).
 * Time Complexity: O(N log N) for all cases.
 * Space Complexity: O(N) due to `std::priority_queue`.
 * @tparam Key Type of the key.
 * @tparam Other Type of the other data.
 * @param a Pointer to the array of Set objects.
 * @param size The number of elements in the array.
 */
template<class Key, class Other>
void heapSort(Set<Key, Other> *a, int size) {
    // Min-heap: smaller key has higher priority.
    // The comparator `lhs.key > rhs.key` makes it a min-heap, meaning
    // `pq.top()` will always return the element with the smallest key.
    auto cmp = [](const Set<Key, Other> &lhs, const Set<Key, Other> &rhs) {
        return lhs.key > rhs.key;
    };

    std::priority_queue<Set<Key, Other>, std::vector<Set<Key, Other>>, decltype(cmp)> pq(cmp);

    // Build the heap by pushing all elements
    for (int i = 0; i < size; ++i) {
        pq.push(a[i]);
    }

    // Extract elements from the heap in sorted order (smallest to largest)
    for (int i = 0; i < size; ++i) {
        a[i] = pq.top();
        pq.pop();
    }
}

/**
 * @brief Helper function for OwnHeapSort: percolates an element down in a max-heap.
 * @tparam Key Type of the key.
 * @tparam Other Type of the other data.
 * @param a The array representing the heap.
 * @param hole The index of the element to percolate down.
 * @param size The current size of the heap.
 */
template<class Key, class Other>
void percolateDown(Set<Key, Other> *a, int hole, int size) {
    Set<Key, Other> tmp = a[hole];
    int child;
    while (hole * 2 + 1 < size) {// Check if left child exists
        child = hole * 2 + 1;    // Left child index

        // Choose the larger child
        if (child + 1 < size && a[child + 1].key > a[child].key) {
            ++child;// Right child exists and is larger
        }

        if (a[child].key > tmp.key) {// If child is larger than current element
            a[hole] = a[child];      // Move child up
            hole = child;            // Move hole down
        } else {
            break;// Element is in its correct position
        }
    }
    a[hole] = tmp;// Place the original element into the hole
}

/**
 * @brief Sorts an array using a custom implementation of Heap Sort (Max-Heap).
 * Time Complexity: O(N log N) for all cases.
 * Space Complexity: O(1).
 * @tparam Key Type of the key.
 * @tparam Other Type of the other data.
 * @param a Pointer to the array of Set objects.
 * @param size The number of elements in the array.
 */
template<class Key, class Other>
void OwnHeapSort(Set<Key, Other> *a, int size) {
    // Phase 1: Build the initial max-heap
    // Start from the last non-leaf node and percolate down
    for (int i = size / 2 - 1; i >= 0; --i) {
        percolateDown(a, i, size);
    }

    // Phase 2: Extract elements from the heap one by one
    // The largest element is always at a[0]. Swap it to the end and reduce heap size.
    for (int i = size - 1; i > 0; --i) {
        std::swap(a[0], a[i]); // Swap root (largest) with the last element of the heap
        percolateDown(a, 0, i);// Restore heap property for the reduced heap
    }
}

/**
 * @brief Partitions an array for QuickSort, using the first element as pivot.
 * @tparam Key Type of the key.
 * @tparam Other Type of the other data.
 * @param a The array to partition.
 * @param low The starting index of the partition.
 * @param high The ending index of the partition.
 * @return The index of the pivot element after partitioning.
 */
template<class Key, class Other>
int partition(Set<Key, Other> *a, int low, int high) {
    Set<Key, Other> pivot = a[low];
    int i = low + 1;
    int j = high;

    while (true) {
        // Find element on left that is greater than pivot
        while (i <= j && a[i].key <= pivot.key) {
            i++;
        }
        // Find element on right that is less than or equal to pivot
        while (i <= j && a[j].key > pivot.key) {
            j--;
        }

        if (i >= j) {// Pointers crossed or met
            break;
        }
        std::swap(a[i], a[j]);// Swap elements
    }
    std::swap(a[low], a[j]);// Place pivot in its correct position
    return j;               // Return pivot's final index
}

/**
 * @brief Recursive helper function for QuickSort.
 * @tparam Key Type of the key.
 * @tparam Other Type of the other data.
 * @param a The array to sort.
 * @param low The starting index of the sub-array.
 * @param high The ending index of the sub-array.
 */
template<class Key, class Other>
void QuicksortRecursive(Set<Key, Other> *a, int low, int high) {
    if (low < high) {                        // Base case: If low is greater than or equal to high, sub-array has 0 or 1 element, already sorted.
        int mid = partition(a, low, high);   // Partition the array and get pivot's index
        QuicksortRecursive(a, low, mid - 1); // Recursively sort left sub-array
        QuicksortRecursive(a, mid + 1, high);// Recursively sort right sub-array
    }
}

/**
 * @brief Sorts an array using the QuickSort algorithm.
 * Time Complexity: O(N log N) on average, O(N^2) in worst case.
 * Space Complexity: O(log N) on average (due to recursion stack), O(N) in worst case.
 * @tparam Key Type of the key.
 * @tparam Other Type of the other data.
 * @param a Pointer to the array of Set objects.
 * @param size The number of elements in the array.
 */
template<class Key, class Other>
void QuickSort(Set<Key, Other> *a, int size) {
    QuicksortRecursive(a, 0, size - 1);
}

/**
 * @brief Partitions an array for Randomized QuickSort, selecting a random pivot.
 * @tparam Key Type of the key.
 * @tparam Other Type of the other data.
 * @param a The array to partition.
 * @param low The starting index of the partition.
 * @param high The ending index of the partition.
 * @return The index of the pivot element after partitioning.
 */
template<class Key, class Other>
int randomizedPartition(Set<Key, Other> *a, int low, int high) {
    static std::mt19937 rng(std::random_device{}());// Initialize once
    std::uniform_int_distribution<int> dist(low, high);
    int randomIndex = dist(rng);// Generate random index within the range

    std::swap(a[low], a[randomIndex]);// Swap the random pivot with the first element
    return partition(a, low, high);   // Use the standard partition logic
}

/**
 * @brief Recursive helper function for Randomized QuickSort.
 * @tparam Key Type of the key.
 * @tparam Other Type of the other data.
 * @param a The array to sort.
 * @param low The starting index of the sub-array.
 * @param high The ending index of the sub-array.
 */
template<class Key, class Other>
void randomizedQuicksortRecursive(Set<Key, Other> *a, int low, int high) {
    if (low < high) {
        int mid = randomizedPartition(a, low, high);
        randomizedQuicksortRecursive(a, low, mid - 1);
        randomizedQuicksortRecursive(a, mid + 1, high);
    }
}

/**
 * @brief Sorts an array using the Randomized QuickSort algorithm.
 * Time Complexity: O(N log N) on average, O(N^2) in worst case (rare due to randomization).
 * Space Complexity: O(log N) on average (due to recursion stack), O(N) in worst case.
 * @tparam Key Type of the key.
 * @tparam Other Type of the other data.
 * @param a Pointer to the array of Set objects.
 * @param size The number of elements in the array.
 */
template<class Key, class Other>
void RandomizedQuickSort(Set<Key, Other> *a, int size) {
    randomizedQuicksortRecursive(a, 0, size - 1);
}

/**
 * @brief Sorts an array using the Bubble Sort algorithm.
 * Time Complexity: O(N^2) for all cases.
 * Space Complexity: O(1).
 * @tparam Key Type of the key.
 * @tparam Other Type of the other data.
 * @param a Pointer to the array of Set objects.
 * @param size The number of elements in the array.
 */
template<class Key, class Other>
void BubbleSort(Set<Key, Other> *a, int size) {
    bool swapped;
    for (int i = 0; i < size - 1; ++i) {
        swapped = false;
        for (int j = 0; j < size - 1 - i; ++j) {// Last i elements are already in place
            if (a[j + 1].key < a[j].key) {
                std::swap(a[j + 1], a[j]);
                swapped = true;
            }
        }
        if (!swapped) {// If no two elements were swapped, array is sorted
            break;
        }
    }
}

/**
 * @brief Sorts an array using the Selection Sort algorithm.
 * Time Complexity: O(N^2) for all cases.
 * Space Complexity: O(1).
 * @tparam Key Type of the key.
 * @tparam Other Type of the other data.
 * @param a Pointer to the array of Set objects.
 * @param size The number of elements in the array.
 */
template<class Key, class Other>
void selectSort(Set<Key, Other> *a, int size) {
    for (int i = 0; i < size - 1; ++i) {
        int min_idx = i;
        // Find the minimum element in the unsorted part
        for (int j = i + 1; j < size; ++j) {
            if (a[j].key < a[min_idx].key) {
                min_idx = j;
            }
        }
        // Swap the found minimum element with the first element of the unsorted part
        if (min_idx != i) {
            std::swap(a[i], a[min_idx]);
        }
    }
}

/**
 * @brief Merges two sorted sub-arrays into a single sorted array.
 * @tparam Key Type of the key.
 * @tparam Other Type of the other data.
 * @param a The original array.
 * @param left The starting index of the first sub-array.
 * @param mid The ending index of the first sub-array (mid + 1 is start of second).
 * @param right The ending index of the second sub-array.
 */
template<class Key, class Other>
void Merge(Set<Key, Other> *a, int left, int mid, int right) {
    // Create a temporary array for merging
    // Size is right - left + 1 because it covers the entire range
    Set<Key, Other> *tmp = new Set<Key, Other>[right - left + 1];

    int i = left;   // Pointer for the first sub-array [left, mid]
    int j = mid + 1;// Pointer for the second sub-array [mid + 1, right]
    int k = 0;      // Pointer for the temporary array

    // Merge elements into tmp array
    while (i <= mid && j <= right) {
        if (a[i].key < a[j].key) {
            tmp[k++] = a[i++];
        } else {
            tmp[k++] = a[j++];
        }
    }

    // Copy remaining elements from the first sub-array (if any)
    while (i <= mid) {
        tmp[k++] = a[i++];
    }

    // Copy remaining elements from the second sub-array (if any)
    while (j <= right) {
        tmp[k++] = a[j++];
    }

    // Copy sorted elements back to the original array
    for (i = 0; i < k; ++i) {// Or for (i = 0, k_orig = left; i < k; ++i, ++k_orig) { a[k_orig] = tmp[i]; }
        a[left + i] = tmp[i];
    }

    delete[] tmp;// Free dynamically allocated memory
}

/**
 * @brief Recursive helper function for MergeSort.
 * @tparam Key Type of the key.
 * @tparam Other Type of the other data.
 * @param a The array to sort.
 * @param left The starting index of the sub-array.
 * @param right The ending index of the sub-array.
 */
template<class Key, class Other>
void MergeSortRecursive(Set<Key, Other> *a, int left, int right) {
    if (left >= right) {// Base case: sub-array has 0 or 1 element, already sorted
        return;
    }

    int mid = left + (right - left) / 2;  // Calculate mid to prevent overflow
    MergeSortRecursive(a, left, mid);     // Sort left half
    MergeSortRecursive(a, mid + 1, right);// Sort right half
    Merge(a, left, mid, right);           // Merge sorted halves
}

/**
 * @brief Sorts an array using the Merge Sort algorithm.
 * Time Complexity: O(N log N) for all cases.
 * Space Complexity: O(N) due to temporary array used in merge.
 * @tparam Key Type of the key.
 * @tparam Other Type of the other data.
 * @param a Pointer to the array of Set objects.
 * @param size The number of elements in the array.
 */
template<class Key, class Other>
void MergeSort(Set<Key, Other> *a, int size) {
    MergeSortRecursive(a, 0, size - 1);
}

// --- Radix Sort (Bucket Sort for integers) ---
// Note: BucketSort is specialized for int keys only due to digit extraction.

/**
 * @brief Structure for nodes in the linked list used by BucketSort.
 * @tparam Other Type of the other data.
 */
template<class Other>
struct Node {
    Set<int, Other> data;
    Node *next;

    Node() : next(nullptr) {}
    Node(const Set<int, Other> &d) : data(d), next(nullptr) {}
};

/**
 * @brief Sorts a linked list of Set<int, Other> using the Radix Sort (Bucket Sort) algorithm.
 * Suitable for non-negative integers.
 * Time Complexity: O(d * (N + k)), where d is number of digits, N is number of elements, k is radix (base).
 * Space Complexity: O(N + k).
 * @tparam Other Type of the other data.
 * @param p Reference to the head of the linked list to be sorted.
 */
template<class Other>
void BucketSort(Node<Other> *&p) {
    Node<Other> *bucket[10];// 10 buckets for digits 0-9
    Node<Other> *last[10];  // To keep track of the tail of each bucket list
    Node<Other> *current;

    if (p == nullptr) return;// Empty list

    // Find the maximum key to determine the number of passes (digits)
    int max_key = 0;
    for (current = p; current != nullptr; current = current->next) {
        if (current->data.key > max_key) {
            max_key = current->data.key;
        }
    }

    // Determine the number of digits in the maximum key
    int num_digits = 0;
    if (max_key == 0) {
        num_digits = 1;// Special case for 0
    } else {
        int temp_max = max_key;
        while (temp_max > 0) {
            temp_max /= 10;
            num_digits++;
        }
    }

    int divisor = 1;// Used to extract digits (1, 10, 100, ...)

    // Perform sorting for each digit
    for (int i = 0; i < num_digits; ++i) {
        // Initialize buckets
        for (int j = 0; j < 10; ++j) {
            bucket[j] = nullptr;
            last[j] = nullptr;
        }

        // Distribute elements into buckets based on the current digit
        current = p;
        while (current != nullptr) {
            int digit = (current->data.key / divisor) % 10;
            if (bucket[digit] == nullptr) {
                bucket[digit] = current;
            } else {
                last[digit]->next = current;
            }
            last[digit] = current;
            current = current->next;
        }

        // Collect elements from buckets back into the main list
        p = nullptr;// Reset head of the main list
        Node<Other> *tail_of_list = nullptr;

        for (int j = 0; j < 10; ++j) {
            if (bucket[j] != nullptr) {// If bucket is not empty
                if (p == nullptr) {
                    p = bucket[j];// Set head of the main list
                } else {
                    tail_of_list->next = bucket[j];// Link previous bucket's tail to current bucket's head
                }
                tail_of_list = last[j];// Update tail of the main list
            }
        }
        if (tail_of_list != nullptr) {
            tail_of_list->next = nullptr;// Ensure the last node points to null
        }
        divisor *= 10;// Move to the next digit
    }
}


// --- Testing Framework ---

/**
 * @brief Tests a given sorting function.
 * @tparam Key Type of the key.
 * @tparam Other Type of the other data.
 * @param sortFunc The sorting function to test.
 * @param test_name The name of the sorting function.
 * @param data_size The number of elements for the test array.
 * @param print_data_on_fail If true, prints the unsorted array on failure.
 * @return True if the sort function passes the test, false otherwise.
 */
template<class Key, class Other>
bool test_sort(SortFunction<Key, Other> sortFunc, const std::string &test_name,
               int data_size, bool print_data_on_fail = false) {
    std::cout << "Testing " << test_name << " with " << data_size << " elements... ";

    // Create a dynamic array to avoid stack overflow for large sizes
    Set<Key, Other> *arr = new Set<Key, Other>[data_size];

    // Fill the array with random data
    for (int i = 0; i < data_size; ++i) {
        arr[i].key = generate_random_int();
        arr[i].other = generate_random_string(10);
    }

    // Create a copy for comparison if needed (e.g., for verifying stability)
    // std::vector<Set<Key, Other>> original_arr(arr, arr + data_size);

    // Measure sorting time
    auto start_time = std::chrono::high_resolution_clock::now();
    sortFunc(arr, data_size);
    auto end_time = std::chrono::high_resolution_clock::now();
    std::chrono::duration<double> elapsed_time = end_time - start_time;

    // Check if the array is sorted in ascending order
    bool sorted = true;
    for (int i = 1; i < data_size; ++i) {
        if (arr[i].key < arr[i - 1].key) {
            sorted = false;
            break;
        }
    }

    if (sorted) {
        std::cout << "PASS (Time: " << elapsed_time.count() * 1000 << " ms)" << std::endl;
    } else {
        std::cout << "FAIL (Time: " << elapsed_time.count() * 1000 << " ms)" << std::endl;
        if (print_data_on_fail) {
            std::cout << "Unsorted array snippet (first 20 elements):" << std::endl;
            for (int i = 0; i < std::min(20, data_size); ++i) {
                std::cout << arr[i] << " ";
            }
            std::cout << std::endl;
        }
    }

    delete[] arr;// Free dynamically allocated memory
    return sorted;
}

/**
 * @brief Tests the BucketSort function (specialized for linked list).
 * @tparam Other Type of the other data.
 * @param test_name The name of the sorting function.
 * @param data_size The number of elements for the test linked list.
 * @param print_data_on_fail If true, prints the unsorted list on failure.
 * @return True if the sort function passes the test, false otherwise.
 */
template<class Other>
bool test_bucket_sort(const std::string &test_name, int data_size, bool print_data_on_fail = false) {
    std::cout << "Testing " << test_name << " with " << data_size << " elements... ";

    Node<Other> *head = nullptr;
    Node<Other> *current = nullptr;

    // Build a linked list with random data
    for (int i = 0; i < data_size; ++i) {
        Set<int, Other> s;
        s.key = generate_random_int();// Max key 100,000 fits well for base 10 radix sort
        s.other = generate_random_string(10);
        Node<Other> *newNode = new Node<Other>(s);
        if (head == nullptr) {
            head = newNode;
            current = newNode;
        } else {
            current->next = newNode;
            current = newNode;
        }
    }

    // Measure sorting time
    auto start_time = std::chrono::high_resolution_clock::now();
    BucketSort(head);
    auto end_time = std::chrono::high_resolution_clock::now();
    std::chrono::duration<double> elapsed_time = end_time - start_time;

    // Check if the list is sorted
    bool sorted = true;
    if (head != nullptr) {
        Node<Other> *prev = head;
        Node<Other> *curr = head->next;
        while (curr != nullptr) {
            if (curr->data.key < prev->data.key) {
                sorted = false;
                break;
            }
            prev = curr;
            curr = curr->next;
        }
    }

    if (sorted) {
        std::cout << "PASS (Time: " << elapsed_time.count() * 1000 << " ms)" << std::endl;
    } else {
        std::cout << "FAIL (Time: " << elapsed_time.count() * 1000 << " ms)" << std::endl;
        if (print_data_on_fail) {
            std::cout << "Unsorted list snippet (first 20 elements):" << std::endl;
            int count = 0;
            current = head;
            while (current != nullptr && count < 20) {
                std::cout << current->data << " ";
                current = current->next;
                count++;
            }
            std::cout << std::endl;
        }
    }

    // Clean up the linked list
    current = head;
    while (current != nullptr) {
        Node<Other> *next_node = current->next;
        delete current;
        current = next_node;
    }
    return sorted;
}

// --- Main Function ---
int main() {
    // Seed the random number generator once for `rand()` used in string generation
    std::srand(static_cast<unsigned int>(std::time(nullptr)));

    // Define the sorting functions to test
    SortFunction<int, std::string> sortFunctions[] = {
            simpleInsertSort,
            shellSort,
            heapSort,
            OwnHeapSort,
            QuickSort,
            RandomizedQuickSort,
            BubbleSort,
            selectSort,
            MergeSort,
    };

    std::vector<std::string> sortNames = {
            "simpleInsertSort",
            "shellSort",
            "heapSort (std::priority_queue)",
            "OwnHeapSort (custom max-heap)",
            "QuickSort (fixed pivot)",
            "RandomizedQuickSort",
            "BubbleSort",
            "selectSort",
            "MergeSort",
    };

    std::cout << "--- Sorting Algorithm Tests (Integer Keys) ---" << std::endl;
    std::cout << "Small data set (100 elements):" << std::endl;
    for (size_t i = 0; i < sortNames.size(); ++i) {
        test_sort(sortFunctions[i], sortNames[i], 100);
    }
    std::cout << "\nLarge data set (10,000 elements):" << std::endl;
    for (size_t i = 0; i < sortNames.size(); ++i) {
        test_sort(sortFunctions[i], sortNames[i], 10000);
    }
    std::cout << "\nVery large data set (100,000 elements):" << std::endl;
    // Note: Some O(N^2) algorithms might be too slow for 100,000 elements
    // Consider commenting out or reducing size for simple sorts if they take too long.
    for (size_t i = 0; i < sortNames.size(); ++i) {
        if (sortNames[i] == "simpleInsertSort" || sortNames[i] == "BubbleSort" || sortNames[i] == "selectSort") {
            std::cout << "Skipping " << sortNames[i] << " for very large data set due to expected long runtime." << std::endl;
            continue;
        }
        test_sort(sortFunctions[i], sortNames[i], 100000);
    }

    std::cout << "\n--- Special Test Cases ---" << std::endl;

    // Test case: Already Sorted Array
    std::cout << "\nTesting with Already Sorted Array (1000 elements):" << std::endl;
    const int sorted_size = 1000;
    Set<int, std::string> *sorted_arr = new Set<int, std::string>[sorted_size];
    for (int i = 0; i < sorted_size; ++i) {
        sorted_arr[i].key = i;// Already sorted
        sorted_arr[i].other = "data";
    }
    for (size_t i = 0; i < sortNames.size(); ++i) {
        if (sortNames[i] == "BucketSort") continue;// BucketSort uses linked list
        std::cout << "  " << sortNames[i] << " (already sorted): ";
        // Make a copy to avoid sorting the original sorted_arr multiple times
        Set<int, std::string> *temp_arr = new Set<int, std::string>[sorted_size];
        std::copy(sorted_arr, sorted_arr + sorted_size, temp_arr);

        auto start_time = std::chrono::high_resolution_clock::now();
        sortFunctions[i](temp_arr, sorted_size);
        auto end_time = std::chrono::high_resolution_clock::now();
        std::chrono::duration<double> elapsed_time = end_time - start_time;

        bool is_sorted = true;
        for (int k = 1; k < sorted_size; ++k) {
            if (temp_arr[k].key < temp_arr[k - 1].key) {
                is_sorted = false;
                break;
            }
        }
        if (is_sorted) {
            std::cout << "PASS (Time: " << elapsed_time.count() * 1000 << " ms)" << std::endl;
        } else {
            std::cout << "FAIL (Time: " << elapsed_time.count() * 1000 << " ms)" << std::endl;
        }
        delete[] temp_arr;
    }
    delete[] sorted_arr;

    // Test case: Reverse Sorted Array (worst case for some algorithms like QuickSort without randomization)
    std::cout << "\nTesting with Reverse Sorted Array (1000 elements):" << std::endl;
    const int reverse_sorted_size = 1000;
    Set<int, std::string> *reverse_arr = new Set<int, std::string>[reverse_sorted_size];
    for (int i = 0; i < reverse_sorted_size; ++i) {
        reverse_arr[i].key = reverse_sorted_size - 1 - i;// Reverse sorted
        reverse_arr[i].other = "data";
    }
    for (size_t i = 0; i < sortNames.size(); ++i) {
        if (sortNames[i] == "BucketSort") continue;
        std::cout << "  " << sortNames[i] << " (reverse sorted): ";
        Set<int, std::string> *temp_arr = new Set<int, std::string>[reverse_sorted_size];
        std::copy(reverse_arr, reverse_arr + reverse_sorted_size, temp_arr);

        auto start_time = std::chrono::high_resolution_clock::now();
        sortFunctions[i](temp_arr, reverse_sorted_size);
        auto end_time = std::chrono::high_resolution_clock::now();
        std::chrono::duration<double> elapsed_time = end_time - start_time;

        bool is_sorted = true;
        for (int k = 1; k < reverse_sorted_size; ++k) {
            if (temp_arr[k].key < temp_arr[k - 1].key) {
                is_sorted = false;
                break;
            }
        }
        if (is_sorted) {
            std::cout << "PASS (Time: " << elapsed_time.count() * 1000 << " ms)" << std::endl;
        } else {
            std::cout << "FAIL (Time: " << elapsed_time.count() * 1000 << " ms)" << std::endl;
        }
        delete[] temp_arr;
    }
    delete[] reverse_arr;

    // Test case: Array with Duplicate Keys
    std::cout << "\nTesting with Array with Duplicate Keys (1000 elements, 5 unique keys):" << std::endl;
    const int duplicate_size = 1000;
    Set<int, std::string> *duplicate_arr = new Set<int, std::string>[duplicate_size];
    for (int i = 0; i < duplicate_size; ++i) {
        duplicate_arr[i].key = i % 5;// Keys will be 0, 1, 2, 3, 4 repeated
        duplicate_arr[i].other = "data";
    }
    // Shuffle the array to make it unsorted but with duplicates
    std::random_device rd;
    std::mt19937 g(rd());
    std::shuffle(duplicate_arr, duplicate_arr + duplicate_size, g);

    for (size_t i = 0; i < sortNames.size(); ++i) {
        if (sortNames[i] == "BucketSort") continue;
        std::cout << "  " << sortNames[i] << " (duplicates): ";
        Set<int, std::string> *temp_arr = new Set<int, std::string>[duplicate_size];
        std::copy(duplicate_arr, duplicate_arr + duplicate_size, temp_arr);

        auto start_time = std::chrono::high_resolution_clock::now();
        sortFunctions[i](temp_arr, duplicate_size);
        auto end_time = std::chrono::high_resolution_clock::now();
        std::chrono::duration<double> elapsed_time = end_time - start_time;

        bool is_sorted = true;
        for (int k = 1; k < duplicate_size; ++k) {
            if (temp_arr[k].key < temp_arr[k - 1].key) {
                is_sorted = false;
                break;
            }
        }
        if (is_sorted) {
            std::cout << "PASS (Time: " << elapsed_time.count() * 1000 << " ms)" << std::endl;
        } else {
            std::cout << "FAIL (Time: " << elapsed_time.count() * 1000 << " ms)" << std::endl;
        }
        delete[] temp_arr;
    }
    delete[] duplicate_arr;

    // Test BucketSort separately as it handles linked lists
    std::cout << "\n--- BucketSort Specific Tests (Integer Keys, Linked List) ---" << std::endl;
    test_bucket_sort<std::string>("BucketSort", 100);
    test_bucket_sort<std::string>("BucketSort", 10000);
    test_bucket_sort<std::string>("BucketSort", 100000);
    test_bucket_sort<std::string>("BucketSort (empty list)", 0);    // Test empty list
    test_bucket_sort<std::string>("BucketSort (single element)", 1);// Test single element

    return 0;
}